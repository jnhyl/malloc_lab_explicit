# malloc_lab explicit version 풀이
크래프톤 정글 과정 중 malloc_lab 과제를 명시적 가용 리스트Explicit Free List로 작성한 코드입니다.

후입선출LIFO 방식으로 구현하여 속도는 빠르나 메모리 효율이 다소 떨어집니다.

## 작성 중 유의 상항
### 매크로와 상수
explicit free list는 가용 블록에 이전과 다음에 생성된 가용 블록들의 주소를 가리키는 포인터를 저장해야 합니다.
책에서는 32비트 머신 기준으로 작성하여 32비트 컴퓨터를 사용하시면 기존 크기를 고수하여도 문제가 없지만 64비트 머신을 쓰는 경우 포인터 크기를 고려해줘야 합니다.
저는 포인터 크기에 맞게 1 word의 크기를 8 bytes로 재조정하였습니다.
그와 더불어 최소 블록 크기 같이 개인적으로 필요한 상수들을 추가하고 잘 안 쓰거나 필요 없다고 느껴지는 상수들은 제거했습니다.
word size를 8 bytes로 바꾸면서 alignment 크기도 변경되었고 그에 맞추어 allocated bit의 영역을 3비트에서 4비트로 늘렸습니다.
교재에서 사용되지만 이해가 안 되는 매크로들은 전부 새로 정의하고 사용하였습니다.

### init
힙의 첫 주소를 가리키는 heap_listp 포인터라던가, 가용 리스트를 가리키는 free_listp는 init을 통해 반드시 초기화해줘야 합니다.
개인적으로 제일 많이 헤맨 부분인데 free_listp 전역 변수의 초기화를 init 밖에서 한 번만 해주는 바람에 오류가 발생하였습니다.
explicit 구현 중 만약 free_listp가 초기화가 안 되어있다면 어떤 오류가 발생할 지 모릅니다.
저 같은 경우는 가용 리스트의 블럭들의 중복 삽입이 발생하면서 가용 블럭의 successor 부분이 자기 참조를 하는 경우가 발생하여 무한루프에 빠졌습니다.
혹시 구현 중에 계신 분이라면 꼭 참고하시길 바랍니다.

### free list 관리
explicit free list는 가용 블록들의 predecessor과 successor 부분의 섬세한 관리가 필요합니다.
free list를 관리하는 함수 구현도 중요하나, 해당 함수들의 오남용으로 가용 리스트에 블록 노드들이 중복 삭제, 중복 삽입이 되지 않도록 각별한 주의가 필요합니다.
또한 predecessor, successor 정보로 인해 할당된 블록의 페이로드 데이터가 오염되지 않도록 유의해야 합니다.
다시 한 번 반복하지만 리스트에 삽입되어 있지 않은 가용 블록 노드가 삭제 되거나 이미 삽입된 가용 블록이 중복 삽입되지 않도록 조십해야 합니다.
엄격한 코드 배치를 통해 해당 문제들을 발생하지 않도록 할 수 있지만, 함수 구현 시 방어 코드를 만들어 놓으면 좀 덜 엄격한 배치로 인한 예상 외의 문제 상황을 막을 수 있습니다.

### realloc
realloc 함수는 총 4가지 케이스로 나누어 최적화를 했으나 유의미한 결과를 보이진 않았습니다.

in-place 방식은 총 세 가지입니다. 
1) 할당 블록 사이즈를 축소시키는 경우
2) 인접한 다음 블록이 충분한 크기의 가용 블록인 경우
3) 마지막 블록일 경우 힙 확장을 통한 공간 확보

3가지의 케이스 어디에도 속하지 않으면 malloc을 통해 새 주소의 공간을 할당 받았습니다.

in-place 방식 구현 시 predecessor과 successor 정보로 인해 페이로드의 데이터가 오염되지 않게 하는 것이 중요합니다.
이미 구현해 놓은 place 함수로는 페이로드가 오염되어서 유사하지만 가용 리스트의 삽입, 삭제로 인한 페이로드 오염이 발생하지 않는 코드를 realloc 공간이 따로 구현했습니다.

### 기타
malloc 함수 중간에 size 크기를 정하는 함수가 삽입되어 있습니다.
해당 함수는 테스트 케이스 중 binary를 대비해서 만들어 졌습니다.
해당 케이스는 일부러 특정 크기의 가용 블록들이 홀수 번째 위치에 반복적으로 배치되도록 만들어놓고, 그 이상의 크기를 할당하도록 명령해서 극악의 메모리 효율을 발생시키는 케이스입니다.
이를 해결하기 위해선 제가 들은 두 가지 방식은 해제 전 할당을 통해 공간을 나눌 때 1) 특정 크기를 요청 받았을 경우 뒤에 올 요청을 대비해 일부러 더 큰 (케이스에서 요구하는) 크기의 공간을 할당 받거나 2) 보조 가용 공간을 만들어서 해제 시 coalesce 시켜주는 것입니다.
이는 제가 알아낸 건 아니고(애초에 이런 테스트 케이스가 있는 지도 몰랐습니다.) 동료의 추천으로 알게 되었습니다.
이를 통해서 퍼포먼스 점수가 5점이나 상승했으니 혹시 2% 부족하게 느껴지시는 분들은 시도해보시길 바랍니다.
